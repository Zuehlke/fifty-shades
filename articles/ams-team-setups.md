---
authorName: Tijana Krstajic, Guido Angenendt
authorGithubUsername: tkrstajic,doogu
issue: 91
title: The evolution of support & operations team setups
---
# {{page.title}}

Each software development project approaches inevitably a GoLive at some point during the software development cycle and enters what we call the Live phase. It's the core purpose of a software development undertaking. Actual end-users start benefiting from implemented features and the sponsoring customer gets the return on investment. However, the phase before and after a GoLive can be intense as well. Aspects around the operational readiness, as well as organizational and procedural considerations regarding the future support and operation of a given software solution are then at the heart of discussions, while the planned GoLive date gets closer and closer.

There are many supporting factors that can lead to a project's success in above matter. One thing is for sure though, the team that is in charge and how the diverse roles collaborate towards the common goal is one significant part of the story. In the following, we therefore present a set of collaboration models for teams, that are transitioning from initial software delivery to continued delivery plus support & operations.

One key good practice from our projects is that colleagues with experience in support & operations matters are involved early in the process. A Service Manager for instance can provide valuable inputs already during the bid phase in terms of Release and Incident Management. Then, a DevOps Engineer can setup a modern CI/CD pipeline already at projects start and by doing so ensure a smooth, high quality releasing from Development to Production environments - aspects that are of value during development and after GoLive. 

Still, when a software development project approaches the Live phase, the team in charge undergoes a shift in focus and setup. Latest then, experts with regard to support & operations matters become constant members of the team and a slight but noticeable shift of mindset takes place. More and more the primary focus of the team isn't only about delivering new features, but also about ensuring smooth support & operations of the productive solution and the satisfaction of end-users.

We believe that this challenge can be mastered best by one team. Over the past years we therefore experimented with a variety of collaboration models for agile teams that are doing just that - development of new features and support & operations of production at the same time. In the following we present three of these models and the related learnings. During the evolution of these models, it turned out to impact mostly the role of a developer and therefore the scenarios are named after it. 

## Fixed Developer
![Fixed Developer](./ams-team-setups/fixed.png)
 
The first scenario we considered is named ‘Fixed Developer’. In that setup, one or many Developers are solely assigned to support & operations activities, like Incident Handling and Event Management. The benefit of such an approach is that there's no capacity impact for ongoing development - as the fixed developer(s) are not participating in that. Also, it ensures that there's always a responsible team member available to respond to support & operations topics. However, this advantage comes along with a huge downside in terms of knowledge transfer. As the developer is not participating in ongoing development, it will be a challenge to support newly developed features on production. As a result, the fixed developer will anyway approach team members that developed particular features in case of issues on production. This fact effectively leads to capacity impact after all, so the upside of this approach turns out to be questionable in practice. Furthermore, a developer is usually not fully allocated to a project in this scenario. Whereas it's a good thing, that there are usually not as many incidents to keep an expert busy 24/7, it leads to practical challenges. Because usually a developer is as a result assigned to multiple projects. This leads to cross-project planning conflicts, in particular when there're incidents to solve at the same time in all of them. Given that in most support & operations contracts there're Service Level Agreements (SLAs) to comply to, this can lead to a considerable challenge. Last but not least, this setup leads to an increased amount of context switching and will therefore reduce the overall efficiency of any person in charge. Given these practical implications, our conclusion is that such a scenario only fits for projects, where there's no ongoing development. 

## Rotating Developer
![Rotating developer](./ams-team-setups/rotating.png)

To mitigate before mentioned downsides, we then experimented with what we call a 'Rotating Developer' setup. Here, the responsibility towards support & operations duties rotates with defined frequencies throughout the team - for instance on a per Sprint basis, if you're doing Scrum. The key changes and related advantages here are threefold. For once, in-between rotations the developers are participating in ongoing development and therefore possess the knowledge needed to support incident resolution on production. On the other hand, developers that fixed issues on production during their rotations will tackle the development of new features with a different perspective. The 'eat your own dog food' effect turns out to have a noticeable positive impact on quality after a couple of rotations. The shorter the rotations cycles are, the speedier this bi-directional knowledge transfer takes place and manifests related benefits. Then, given the the twofold duties, a developer can be allocated fully to one project, which mitigates a central issue of the Fixed Developer approach in terms of SLA compliance and cross-project context switching. However, also this collaboration model shows downsides in practice. During their rotations, developers cannot be assigned fully to backlog work - as some capacity needs to be reserved for supporting production. Furthermore, it can happen at times, that the reserved capacity is not sufficient, e.g. in the context of high severity incidents that require and increased amount of troubleshooting and resolution efforts. Over time this effect levels up, but i can happen that a given Sprint goal is jeopardized due to this setup. Lastly, this model is a challenge in situations where there's a broad spectrum of technologies in use for the software solution at hand. That's simply because one single developer is usually not an expert in all areas. But given a less diverse technology mix, this model is well suited in particular for projects with strict delivery timelines - as the rotation model introduces appropriate planning means. 

## One Team

![One Team](./ams-team-setups/one.png)

The motivation to continuously improve our team setups has led to a third and most recent model. It integrates the benefits of former models and attempts to mitigate two remaining downsides. As noted earlier, it's a challenge to take over responsibility for support & operations as a developer in projects where there's a diverse technology mix. Furthermore, despite having established a lean knowledge transfer due to rotations, there's still some overhead involved - e.g. when one developer hands over ongoing tasks to the next one in charge. We therefore started to experiment with team setups, where the whole team is continuously in charge for both ongoing development and support & operations topics - therefore called 'One Team' model. In contrast to the Rotating Developer setup, it's not a single dedicated developer at a time that is in charge for production. Once an Incident comes in, the team decides who's best suited to tackle the issue in terms of knowledge and capacity. Therefore, this model is suited for projects with a diverse technology mix. Furthermore, it significantly increases efficiency, which is due to two main aspects. First, any team member that takes over the task of resolving an issue on production will finish it without the need of a handover due to rotations. Secondly, don't underestimate the power of a team being in charge of a shared goal, all together as One Team. Different from former setups, this team spirit releases supportive behaviours that lead to an overall more efficient handling of tasks. For instance, even if a specific team member has taken over the tasks of resolving an incident on production, the remainder of the team will provide more input and support then in a scenario where this responsibility is delegated to a single person in charge. Furthermore, the before mentioned 'eat your own dog food' effect scales  in that matter. With a team being very aware of the challenges of any given software solution on production will take very informed decisions regarding new features during ongoing development and therefore deliver better software. However, also this collaboration model has it's downsides. Most notably, the degree of issues to resolve on production at times impacts the velocity of an agile team regarding the ongoing development. Due to the efficiency gain of that setup, this levels over time and as a matter of fact no other model allows for a faster and higher quality resolution of incidents. Still, it can happen that a Sprint goal gets jeopardized and worst case delivery timelines endangered. Therefore, this setup is best suited for projects with a balanced priority between delivery and maintenance streams. If it's possible to postpone the delivery of some less crucial new features for the greater good of stable operations on production at times, then this model is the best choice. Again, experience with this model shows that this decision is actually not often needed, due to the increased efficiency of One Team with shared goals.

As you can see, the collaboration models did undergo an evolution over time,  starting from Fixed Developer as a logical and simple setup to start with over Rotating Developer and lastly One Team as a logical conclusion: The overall goals are one, so the team should be one and share the responsibility. We are part of projects to support the success of our customers and therefore will continue to strive for improvements in all areas that contribute to that. 

*By {{page.authorName}}*