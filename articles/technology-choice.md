---
authorName: Carsten Kind
authorGithubUsername: carstenkind
issue: 100
title: Die beste Technologie ist nicht immer die beste Wahl 
---
# {{page.title}}

Als Technologie-Berater hat man die Verantwortung eine für den Kunden passende Technologie zu empfehlen. Klingt einfach, ist es aber nicht. Insbesondere, wenn man im eigenem Unternehmen viele neue Technologien kennen lernt, und diese mit den Kollegen diskutiert und so vertraut mit ihnen wird. Der Kontext in dem die Technologie eingesetzt werden soll, muss berücksichtigt werden. Das heißt, dass nicht immer die technologisch beste Technologie auch die richtige Technologie für den Kunden ist. Auch das klingt erst einmal wie eine triviale Aussage, aber, wenn man selbst sieht, wie die neueste Technologie die funktionalen Anforderungen X und Z ermöglicht, und außerdem die nichtfunktionale Anforderung Y erfüllt, dann fällt die Entscheidung doch schwer, und es wird eine echte Trade-Off -Entscheidung. 

Ich möchte anhand von zwei Beispielen aus der Praxis zeigen, wie schwierig diese Entscheidung ist. 

Ein Maschinenbauer wollte eine neue Einrichtungs- und Bediensoftware für seine hoch spezialisierten Maschinen entwickeln. Wie genau am Ende das Datenmodell aussieht war unklar, und es gab die Anforderung, dass man ein genaues Audit brauchte, wer was genau an der Maschine eingestellt hat. Wir haben uns daraufhin entschieden Event-Sourcing einzusetzen. Dabei bildet die primäre Datenquelle nicht ein relationales Datenbankmodell, das die Entitäten abbildet, sondern eine Liste von Events, die die Änderung des Systemzustands beschreiben. Für uns waren damit eine Reihe von Vorteilen verknüpft: 
* Das Objektmodell auf dem man arbeitet, kann ohne Rücksicht auf die Vergangenheit weiterentwickelt werden. Man muss nur dafür sorgen, dass die bereits gespeicherten Events auf das neue Datenmodell angewendet werden können. So kann man es immer wieder herstellen. 
* Wir haben garantiert alle notwendigen Daten, um das Audit darstellen zu können. 
* Im Gegensatz zu einer separat zu pflegenden Audit-Tabelle haben wir mit den Events intrinsisch verhindert, dass Entwickler den Audit-Eintrag vergessen können. 
Wie bereits von Anfang an geplant, hat der Maschinenbauer eine schlagkräftige Entwicklungsmannschaft aufgebaut und die Entwicklung schließlich in die eigenen Hände genommen. Die neue Entwicklungsmannschaft kannte jedoch in erster Linie die Technologien für klassische datengetriebene Anwendungen, und als diese nun selbst die Verantwortung über die Architektur und die Weiterentwicklung der Maschinensoftware übernahm, hat sie sich unwohl gefühlt, mit einer Architektur, die sie so nie zuvor gesehen haben. Am Ende haben sie die Anwendung wieder auf eine relationale Datenbank umgestellt. Auch damit sind sie aktuell erfolgreich. Rückblickend haben wir nicht den Eindruck, dass wir viel falsch gemacht haben, aber die Unsicherheit eines neuen Teams mit dieser Architektur haben wir offenbar unterschätzt, und zwingend erforderlich war das Event-Sourcing-Konzept auch nicht. Es war vorteilhaft. 

Das zweite Beispiel: 2009/2010 hat Eric Meijer bei Microsoft die Reactive Extensions erfunden. Dies war zunächst eine .Net-Bibliothek, mit der Events als Objekte ausgedrückt werden konnten, und komplexe Event-Sequenzen als höherwertige Events ausgedrückt werden können. Bereits die ersten Beispiele zeigten das breite Einsatzspektrum dieser Bibliothek: 
* Ein Beispiel zeigte, wie aus einem Sensorwert durch mehrfache Transformation ein valider Alarm wird. Das bedeutet periodisch Wert abfragen, Mittelwert über letzte Werte bilden, Abbildung auf binäre Werte und Propagation nur bei Änderung. 
* Ein anderes Beispiel zeigte, wie die Anforderungen an eine Autocomplete-Auswahlbox implementiert werden kann. Das bedeutet, dass die Suchabfrage für die Vorschläge nicht abgesetzt wird, wenn der Text leer ist oder noch getippt wird, und auch, dass eine laufende Abfrage abgebrochen wird, wenn weiter getippt wird. 
* Sehr früh haben wir auch den Wert in der Gestenerkennung gesehen, wo wir aus der Abfolge bestimmter Bewegungen bestimmte Gesten identifizieren konnten, und haben das mit Hilfe der Kinect auf Messeauftritten demonstriert. 
* Auch andere haben einen großen Wert in dieser Bibliothek gesehen, sodass diese Bibliothek in zahlreiche Programmiersprachen portiert wurde. 
* Microsoft hat seinerzeit diese Bibliothek sogar in das .NET-Framework für seine Windows Phones übernommen. 
Dennoch hat diese Bibliothek über Jahre nur eine geringe Verbreitung gehabt und man musste aufpassen, ob man diese Bibliothek guten Gewissens einsetzen kann. Die Bibliothek greift einige Ansätze aus der funktionalen Programmierung auf. So werden bevor irgendein Event auftritt, die ganzen Funktionsketten definiert, was passieren soll, wenn ein Event auftreten sollte. Diese Events werden als Observables angeboten, und erst wenn ein Konsument dieser Observables sich für die potentiellen Ergebnisse interessiert, werden die Events erzeugt oder wahrgenommen. So leistungsfähig dieses Konzept auch ist, verursacht es bei einem nicht ausgebildeten Entwickler Kopfzerbrechen. 
So gibt es den Fall, dass in einem unserer Projekte die Reactive Extensions wieder ausgebaut wurden, weil der Entwickler, der einen schwierigen Bug beheben sollte, den Code nicht verstanden hat. Aber der Bug war am Ende woanders. 
Es gibt das positive Beispiel, dass bei einem Kunden die Reactive Extensions als interne API für Web-Services eingesetzt wurden. Das war riskant, weil diese Lösung zwar technisch den Alternativen überlegen ist, aber seinerzeit nicht üblich war. Das war nur zu vertreten, weil der Kunde bereits ein stabiles Entwicklungsteam hatte, dass die Entscheidung mittragen konnte. 
Das eine gute Lösung Jahre und Marketing braucht, bis es Mainstream wird, zeigt das Beispiel auch. Google hat im Angular2-Framework auf die JavaScript-Variante der Reactive Extensions (RxJS) zurückgegriffen, um genau das gleiche zu tun – nur eben 5 Jahre später. Nun gibt es auf zahlreichen Konferenzen Vorträge zu RxJS und wie es eingesetzt wird. Es kommt durch Google raus aus der Nische. Jetzt kann man diese Technologie auch empfehlen, wenn man keinen längerfristigen Zugriff auf das Entwicklungsteam hat, um es zu schulen. 
Wenn also eine Technologie oder eine Architektur interessant ist, weil sie zum Problem passt, aber ein Nischendasein führt oder gerade erst im Aufwind ist, muss man sicherstellen, dass das Entwicklungsteam diese Technologie versteht, die Vorteile erkennt und selbst davon überzeugt ist. Denn viel Bestätigung, dass es die richtige Technologie einsetzt, wird das Team nicht bekommen.

*By {{page.authorName}}*
